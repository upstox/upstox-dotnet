// <auto-generated>
/*
 * OpenAPI definition
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using UpstoxClient.Client;

namespace UpstoxClient.Model
{
    /// <summary>
    /// ExpiredFutureData
    /// </summary>
    public partial class ExpiredFutureData
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ExpiredFutureData" /> class.
        /// </summary>
        /// <param name="name">Name of the instrument</param>
        /// <param name="segment">Segment of the instrument</param>
        /// <param name="exchange">Exchange of the instrument</param>
        /// <param name="expiry">Expiry date of the instrument</param>
        /// <param name="instrumentKey">Unique key identifying the instrument</param>
        /// <param name="exchangeToken">Token assigned by the exchange</param>
        /// <param name="tradingSymbol">Symbol used for trading</param>
        /// <param name="tickSize">Minimum price movement</param>
        /// <param name="lotSize">Number of units per lot</param>
        /// <param name="instrumentType">Type of the instrument</param>
        /// <param name="freezeQuantity">Maximum allowed quantity</param>
        /// <param name="underlyingKey">Key of the underlying asset</param>
        /// <param name="underlyingType">Type of the underlying asset</param>
        /// <param name="underlyingSymbol">Symbol of the underlying asset</param>
        /// <param name="minimumLot">Minimum lot size</param>
        [JsonConstructor]
        public ExpiredFutureData(Option<string?> name = default, Option<string?> segment = default, Option<string?> exchange = default, Option<string?> expiry = default, Option<string?> instrumentKey = default, Option<string?> exchangeToken = default, Option<string?> tradingSymbol = default, Option<double?> tickSize = default, Option<long?> lotSize = default, Option<string?> instrumentType = default, Option<double?> freezeQuantity = default, Option<string?> underlyingKey = default, Option<string?> underlyingType = default, Option<string?> underlyingSymbol = default, Option<long?> minimumLot = default)
        {
            NameOption = name;
            SegmentOption = segment;
            ExchangeOption = exchange;
            ExpiryOption = expiry;
            InstrumentKeyOption = instrumentKey;
            ExchangeTokenOption = exchangeToken;
            TradingSymbolOption = tradingSymbol;
            TickSizeOption = tickSize;
            LotSizeOption = lotSize;
            InstrumentTypeOption = instrumentType;
            FreezeQuantityOption = freezeQuantity;
            UnderlyingKeyOption = underlyingKey;
            UnderlyingTypeOption = underlyingType;
            UnderlyingSymbolOption = underlyingSymbol;
            MinimumLotOption = minimumLot;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// Used to track the state of Name
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> NameOption { get; private set; }

        /// <summary>
        /// Name of the instrument
        /// </summary>
        /// <value>Name of the instrument</value>
        /* <example>NIFTY</example> */
        [JsonPropertyName("name")]
        public string? Name { get { return this.NameOption; } set { this.NameOption = new(value); } }

        /// <summary>
        /// Used to track the state of Segment
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> SegmentOption { get; private set; }

        /// <summary>
        /// Segment of the instrument
        /// </summary>
        /// <value>Segment of the instrument</value>
        /* <example>NSE_FO</example> */
        [JsonPropertyName("segment")]
        public string? Segment { get { return this.SegmentOption; } set { this.SegmentOption = new(value); } }

        /// <summary>
        /// Used to track the state of Exchange
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> ExchangeOption { get; private set; }

        /// <summary>
        /// Exchange of the instrument
        /// </summary>
        /// <value>Exchange of the instrument</value>
        /* <example>NSE</example> */
        [JsonPropertyName("exchange")]
        public string? Exchange { get { return this.ExchangeOption; } set { this.ExchangeOption = new(value); } }

        /// <summary>
        /// Used to track the state of Expiry
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> ExpiryOption { get; private set; }

        /// <summary>
        /// Expiry date of the instrument
        /// </summary>
        /// <value>Expiry date of the instrument</value>
        /* <example>2024-12-26</example> */
        [JsonPropertyName("expiry")]
        public string? Expiry { get { return this.ExpiryOption; } set { this.ExpiryOption = new(value); } }

        /// <summary>
        /// Used to track the state of InstrumentKey
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> InstrumentKeyOption { get; private set; }

        /// <summary>
        /// Unique key identifying the instrument
        /// </summary>
        /// <value>Unique key identifying the instrument</value>
        /* <example>NSE_FO|35005</example> */
        [JsonPropertyName("instrument_key")]
        public string? InstrumentKey { get { return this.InstrumentKeyOption; } set { this.InstrumentKeyOption = new(value); } }

        /// <summary>
        /// Used to track the state of ExchangeToken
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> ExchangeTokenOption { get; private set; }

        /// <summary>
        /// Token assigned by the exchange
        /// </summary>
        /// <value>Token assigned by the exchange</value>
        /* <example>35005</example> */
        [JsonPropertyName("exchange_token")]
        public string? ExchangeToken { get { return this.ExchangeTokenOption; } set { this.ExchangeTokenOption = new(value); } }

        /// <summary>
        /// Used to track the state of TradingSymbol
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> TradingSymbolOption { get; private set; }

        /// <summary>
        /// Symbol used for trading
        /// </summary>
        /// <value>Symbol used for trading</value>
        /* <example>NIFTY FUT 26 DEC 24</example> */
        [JsonPropertyName("trading_symbol")]
        public string? TradingSymbol { get { return this.TradingSymbolOption; } set { this.TradingSymbolOption = new(value); } }

        /// <summary>
        /// Used to track the state of TickSize
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<double?> TickSizeOption { get; private set; }

        /// <summary>
        /// Minimum price movement
        /// </summary>
        /// <value>Minimum price movement</value>
        /* <example>5</example> */
        [JsonPropertyName("tick_size")]
        public double? TickSize { get { return this.TickSizeOption; } set { this.TickSizeOption = new(value); } }

        /// <summary>
        /// Used to track the state of LotSize
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<long?> LotSizeOption { get; private set; }

        /// <summary>
        /// Number of units per lot
        /// </summary>
        /// <value>Number of units per lot</value>
        /* <example>25</example> */
        [JsonPropertyName("lot_size")]
        public long? LotSize { get { return this.LotSizeOption; } set { this.LotSizeOption = new(value); } }

        /// <summary>
        /// Used to track the state of InstrumentType
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> InstrumentTypeOption { get; private set; }

        /// <summary>
        /// Type of the instrument
        /// </summary>
        /// <value>Type of the instrument</value>
        /* <example>FUT</example> */
        [JsonPropertyName("instrument_type")]
        public string? InstrumentType { get { return this.InstrumentTypeOption; } set { this.InstrumentTypeOption = new(value); } }

        /// <summary>
        /// Used to track the state of FreezeQuantity
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<double?> FreezeQuantityOption { get; private set; }

        /// <summary>
        /// Maximum allowed quantity
        /// </summary>
        /// <value>Maximum allowed quantity</value>
        /* <example>1800</example> */
        [JsonPropertyName("freeze_quantity")]
        public double? FreezeQuantity { get { return this.FreezeQuantityOption; } set { this.FreezeQuantityOption = new(value); } }

        /// <summary>
        /// Used to track the state of UnderlyingKey
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> UnderlyingKeyOption { get; private set; }

        /// <summary>
        /// Key of the underlying asset
        /// </summary>
        /// <value>Key of the underlying asset</value>
        /* <example>NSE_INDEX|Nifty 50</example> */
        [JsonPropertyName("underlying_key")]
        public string? UnderlyingKey { get { return this.UnderlyingKeyOption; } set { this.UnderlyingKeyOption = new(value); } }

        /// <summary>
        /// Used to track the state of UnderlyingType
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> UnderlyingTypeOption { get; private set; }

        /// <summary>
        /// Type of the underlying asset
        /// </summary>
        /// <value>Type of the underlying asset</value>
        /* <example>INDEX</example> */
        [JsonPropertyName("underlying_type")]
        public string? UnderlyingType { get { return this.UnderlyingTypeOption; } set { this.UnderlyingTypeOption = new(value); } }

        /// <summary>
        /// Used to track the state of UnderlyingSymbol
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> UnderlyingSymbolOption { get; private set; }

        /// <summary>
        /// Symbol of the underlying asset
        /// </summary>
        /// <value>Symbol of the underlying asset</value>
        /* <example>NIFTY</example> */
        [JsonPropertyName("underlying_symbol")]
        public string? UnderlyingSymbol { get { return this.UnderlyingSymbolOption; } set { this.UnderlyingSymbolOption = new(value); } }

        /// <summary>
        /// Used to track the state of MinimumLot
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<long?> MinimumLotOption { get; private set; }

        /// <summary>
        /// Minimum lot size
        /// </summary>
        /// <value>Minimum lot size</value>
        /* <example>25</example> */
        [JsonPropertyName("minimum_lot")]
        public long? MinimumLot { get { return this.MinimumLotOption; } set { this.MinimumLotOption = new(value); } }

        /// <summary>
        /// Gets or Sets additional properties
        /// </summary>
        [JsonExtensionData]
        public Dictionary<string, JsonElement> AdditionalProperties { get; } = new Dictionary<string, JsonElement>();

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class ExpiredFutureData {\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  Segment: ").Append(Segment).Append("\n");
            sb.Append("  Exchange: ").Append(Exchange).Append("\n");
            sb.Append("  Expiry: ").Append(Expiry).Append("\n");
            sb.Append("  InstrumentKey: ").Append(InstrumentKey).Append("\n");
            sb.Append("  ExchangeToken: ").Append(ExchangeToken).Append("\n");
            sb.Append("  TradingSymbol: ").Append(TradingSymbol).Append("\n");
            sb.Append("  TickSize: ").Append(TickSize).Append("\n");
            sb.Append("  LotSize: ").Append(LotSize).Append("\n");
            sb.Append("  InstrumentType: ").Append(InstrumentType).Append("\n");
            sb.Append("  FreezeQuantity: ").Append(FreezeQuantity).Append("\n");
            sb.Append("  UnderlyingKey: ").Append(UnderlyingKey).Append("\n");
            sb.Append("  UnderlyingType: ").Append(UnderlyingType).Append("\n");
            sb.Append("  UnderlyingSymbol: ").Append(UnderlyingSymbol).Append("\n");
            sb.Append("  MinimumLot: ").Append(MinimumLot).Append("\n");
            sb.Append("  AdditionalProperties: ").Append(AdditionalProperties).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="ExpiredFutureData" />
    /// </summary>
    public class ExpiredFutureDataJsonConverter : JsonConverter<ExpiredFutureData>
    {
        /// <summary>
        /// Deserializes json to <see cref="ExpiredFutureData" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override ExpiredFutureData Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<string?> name = default;
            Option<string?> segment = default;
            Option<string?> exchange = default;
            Option<string?> expiry = default;
            Option<string?> instrumentKey = default;
            Option<string?> exchangeToken = default;
            Option<string?> tradingSymbol = default;
            Option<double?> tickSize = default;
            Option<long?> lotSize = default;
            Option<string?> instrumentType = default;
            Option<double?> freezeQuantity = default;
            Option<string?> underlyingKey = default;
            Option<string?> underlyingType = default;
            Option<string?> underlyingSymbol = default;
            Option<long?> minimumLot = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "name":
                            name = new Option<string?>(utf8JsonReader.GetString());
                            break;
                        case "segment":
                            segment = new Option<string?>(utf8JsonReader.GetString());
                            break;
                        case "exchange":
                            exchange = new Option<string?>(utf8JsonReader.GetString());
                            break;
                        case "expiry":
                            expiry = new Option<string?>(utf8JsonReader.GetString());
                            break;
                        case "instrument_key":
                            instrumentKey = new Option<string?>(utf8JsonReader.GetString());
                            break;
                        case "exchange_token":
                            exchangeToken = new Option<string?>(utf8JsonReader.GetString());
                            break;
                        case "trading_symbol":
                            tradingSymbol = new Option<string?>(utf8JsonReader.GetString());
                            break;
                        case "tick_size":
                            tickSize = new Option<double?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (double?)null : utf8JsonReader.GetDouble());
                            break;
                        case "lot_size":
                            lotSize = new Option<long?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (long?)null : utf8JsonReader.GetInt64());
                            break;
                        case "instrument_type":
                            instrumentType = new Option<string?>(utf8JsonReader.GetString());
                            break;
                        case "freeze_quantity":
                            freezeQuantity = new Option<double?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (double?)null : utf8JsonReader.GetDouble());
                            break;
                        case "underlying_key":
                            underlyingKey = new Option<string?>(utf8JsonReader.GetString());
                            break;
                        case "underlying_type":
                            underlyingType = new Option<string?>(utf8JsonReader.GetString());
                            break;
                        case "underlying_symbol":
                            underlyingSymbol = new Option<string?>(utf8JsonReader.GetString());
                            break;
                        case "minimum_lot":
                            minimumLot = new Option<long?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (long?)null : utf8JsonReader.GetInt64());
                            break;
                        default:
                            break;
                    }
                }
            }

            return new ExpiredFutureData(name, segment, exchange, expiry, instrumentKey, exchangeToken, tradingSymbol, tickSize, lotSize, instrumentType, freezeQuantity, underlyingKey, underlyingType, underlyingSymbol, minimumLot);
        }

        /// <summary>
        /// Serializes a <see cref="ExpiredFutureData" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="expiredFutureData"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, ExpiredFutureData expiredFutureData, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, expiredFutureData, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="ExpiredFutureData" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="expiredFutureData"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, ExpiredFutureData expiredFutureData, JsonSerializerOptions jsonSerializerOptions)
        {
            if (expiredFutureData.NameOption.IsSet)
                if (expiredFutureData.NameOption.Value != null)
                    writer.WriteString("name", expiredFutureData.Name);
                else
                    writer.WriteNull("name");

            if (expiredFutureData.SegmentOption.IsSet)
                if (expiredFutureData.SegmentOption.Value != null)
                    writer.WriteString("segment", expiredFutureData.Segment);
                else
                    writer.WriteNull("segment");

            if (expiredFutureData.ExchangeOption.IsSet)
                if (expiredFutureData.ExchangeOption.Value != null)
                    writer.WriteString("exchange", expiredFutureData.Exchange);
                else
                    writer.WriteNull("exchange");

            if (expiredFutureData.ExpiryOption.IsSet)
                if (expiredFutureData.ExpiryOption.Value != null)
                    writer.WriteString("expiry", expiredFutureData.Expiry);
                else
                    writer.WriteNull("expiry");

            if (expiredFutureData.InstrumentKeyOption.IsSet)
                if (expiredFutureData.InstrumentKeyOption.Value != null)
                    writer.WriteString("instrument_key", expiredFutureData.InstrumentKey);
                else
                    writer.WriteNull("instrument_key");

            if (expiredFutureData.ExchangeTokenOption.IsSet)
                if (expiredFutureData.ExchangeTokenOption.Value != null)
                    writer.WriteString("exchange_token", expiredFutureData.ExchangeToken);
                else
                    writer.WriteNull("exchange_token");

            if (expiredFutureData.TradingSymbolOption.IsSet)
                if (expiredFutureData.TradingSymbolOption.Value != null)
                    writer.WriteString("trading_symbol", expiredFutureData.TradingSymbol);
                else
                    writer.WriteNull("trading_symbol");

            if (expiredFutureData.TickSizeOption.IsSet)
                if (expiredFutureData.TickSizeOption.Value != null)
                    writer.WriteNumber("tick_size", expiredFutureData.TickSizeOption.Value!.Value);
                else
                    writer.WriteNull("tick_size");

            if (expiredFutureData.LotSizeOption.IsSet)
                if (expiredFutureData.LotSizeOption.Value != null)
                    writer.WriteNumber("lot_size", expiredFutureData.LotSizeOption.Value!.Value);
                else
                    writer.WriteNull("lot_size");

            if (expiredFutureData.InstrumentTypeOption.IsSet)
                if (expiredFutureData.InstrumentTypeOption.Value != null)
                    writer.WriteString("instrument_type", expiredFutureData.InstrumentType);
                else
                    writer.WriteNull("instrument_type");

            if (expiredFutureData.FreezeQuantityOption.IsSet)
                if (expiredFutureData.FreezeQuantityOption.Value != null)
                    writer.WriteNumber("freeze_quantity", expiredFutureData.FreezeQuantityOption.Value!.Value);
                else
                    writer.WriteNull("freeze_quantity");

            if (expiredFutureData.UnderlyingKeyOption.IsSet)
                if (expiredFutureData.UnderlyingKeyOption.Value != null)
                    writer.WriteString("underlying_key", expiredFutureData.UnderlyingKey);
                else
                    writer.WriteNull("underlying_key");

            if (expiredFutureData.UnderlyingTypeOption.IsSet)
                if (expiredFutureData.UnderlyingTypeOption.Value != null)
                    writer.WriteString("underlying_type", expiredFutureData.UnderlyingType);
                else
                    writer.WriteNull("underlying_type");

            if (expiredFutureData.UnderlyingSymbolOption.IsSet)
                if (expiredFutureData.UnderlyingSymbolOption.Value != null)
                    writer.WriteString("underlying_symbol", expiredFutureData.UnderlyingSymbol);
                else
                    writer.WriteNull("underlying_symbol");

            if (expiredFutureData.MinimumLotOption.IsSet)
                if (expiredFutureData.MinimumLotOption.Value != null)
                    writer.WriteNumber("minimum_lot", expiredFutureData.MinimumLotOption.Value!.Value);
                else
                    writer.WriteNull("minimum_lot");
        }
    }
}
